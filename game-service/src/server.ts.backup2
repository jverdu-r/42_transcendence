import Fastify from 'fastify';
import fastifyWebsocket from '@fastify/websocket';
import fastifyCors from '@fastify/cors';
import { v4 as uuidv4 } from 'uuid';
import { WebSocket } from 'ws';
import { GameManager } from './game/GameManager.js';
import { AIPlayer } from './game/AIPlayer.js';
import { GameUtils } from './utils/gameUtils.js';
import { Player, GameMessage, PlayerInput, GameMode } from './types/game.js';

const fastify = Fastify({
  logger: {
    level: 'info'
  }
});

// Game Manager instance
const gameManager = new GameManager();

// WebSocket connections
const connections = new Map<string, WebSocket>();

// Player to client mapping
const playerToClient = new Map<string, string>();
const clientToPlayer = new Map<string, string>();

// Register plugins
fastify.register(fastifyWebsocket, {
  options: {
    maxPayload: 1048576,
    verifyClient: (info: any) => {
      fastify.log.info('WebSocket client attempting to connect', { origin: info.origin });
      return true;
    }
  }
});

fastify.register(fastifyCors, {
  origin: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  credentials: true
});

// Helper function to send message to specific client
function sendToClient(clientId: string, message: GameMessage): void {
  const connection = connections.get(clientId);
  if (connection && connection.readyState === WebSocket.OPEN) {
    connection.send(JSON.stringify(message));
  }
}

// Helper function to broadcast to all clients in a game
function broadcastToGame(gameId: string, message: GameMessage): void {
  const game = gameManager.getGame(gameId);
  if (game) {
    game.getPlayers().forEach((player: Player) => {
      if (player.isConnected) {
        const clientId = playerToClient.get(player.id);
        if (clientId) {
          sendToClient(clientId, message);
        }
      }
    });
  }
}

// WebSocket route handler
fastify.register(async function (fastify) {
  fastify.get('/ws', { websocket: true }, (connection, request) => {
    const clientId = uuidv4();
    connections.set(clientId, connection.socket);
    
    fastify.log.info(`üîó Client connected: ${clientId}`);
    
    // Send connection confirmation
    sendToClient(clientId, {
      type: 'connection',
      data: { clientId, message: 'Connected to game server' }
    });

    connection.socket.on('message', async (message) => {
      try {
        const data = JSON.parse(message.toString());
        fastify.log.info(`üì® Message from ${clientId}:`, data);
        
        await handleClientMessage(clientId, data);
      } catch (error) {
        fastify.log.error('Error processing message:', error);
        sendToClient(clientId, {
          type: 'error',
          data: { message: 'Invalid message format' }
        });
      }
    });

    connection.socket.on('close', () => {
      fastify.log.info(`üîå Client disconnected: ${clientId}`);
      handleClientDisconnect(clientId);
      connections.delete(clientId);
    });

    connection.socket.on('error', (error) => {
      fastify.log.error(`‚ùå WebSocket error for client ${clientId}:`, error);
    });
  });
});

// Handle client messages
async function handleClientMessage(clientId: string, message: any): Promise<void> {
  const { type, data } = message;

  switch (type) {
    case 'createGame':
      await handleCreateGame(clientId, data);
      break;
    case 'joinGame':
      await handleJoinGame(clientId, data);
      break;
    case 'startGame':
      await handleStartGame(clientId, data);
      break;
    case 'playerMove':
      await handlePlayerMove(clientId, data);
      break;
    case 'getGames':
      await handleGetGames(clientId);
      break;
    case 'getGameState':
      await handleGetGameState(clientId, data);
      break;
    case 'leaveGame':
      await handleLeaveGame(clientId, data);
      break;
    default:
      fastify.log.warn(`Unknown message type: ${type}`);
      sendToClient(clientId, {
        type: 'error',
        data: { message: `Unknown message type: ${type}` }
      });
  }
}

// Create a new game
async function handleCreateGame(clientId: string, data: any): Promise<void> {
  try {
    const { playerName, gameMode = 'pvp', aiDifficulty = 'medium' } = data;
    
    const gameId = gameManager.createGame(playerName, gameMode as GameMode);
    const game = gameManager.getGame(gameId);
    
    if (game) {
      const player = game.getPlayers()[0]; // First player
      if (player) {
        playerToClient.set(player.id, clientId);
        clientToPlayer.set(clientId, player.id);
      }
    }
    
    // If PvE mode, add AI player
    if (gameMode === 'pve') {
      gameManager.joinGame(gameId, `AI (${aiDifficulty})`);
    }
    
    sendToClient(clientId, {
      type: 'gameCreated',
      data: { gameId, playerNumber: 1, gameMode }
    });
    
    fastify.log.info(`üéÆ Game created: ${gameId} by ${playerName}`);
  } catch (error) {
    fastify.log.error('Error creating game:', error);
    sendToClient(clientId, {
      type: 'error',
      data: { message: 'Failed to create game' }
    });
  }
}

// Join an existing game
async function handleJoinGame(clientId: string, data: any): Promise<void> {
  try {
    const { gameId, playerName } = data;
    
    const success = gameManager.joinGame(gameId, playerName);
    
    if (success) {
      const game = gameManager.getGame(gameId);
      if (game) {
        const players = game.getPlayers();
        const player = players.find(p => p.name === playerName && !p.isAI);
        if (player) {
          playerToClient.set(player.id, clientId);
          clientToPlayer.set(clientId, player.id);
        }
      }
      
      sendToClient(clientId, {
        type: 'gameJoined',
        data: { gameId, playerNumber: 2 }
      });
      
      // Notify other players
      broadcastToGame(gameId, {
        type: 'playerJoined',
        data: { playerName, playerNumber: 2 }
      });
      
      fastify.log.info(`üë• Player ${playerName} joined game ${gameId}`);
    } else {
      sendToClient(clientId, {
        type: 'error',
        data: { message: 'Failed to join game' }
      });
    }
  } catch (error) {
    fastify.log.error('Error joining game:', error);
    sendToClient(clientId, {
      type: 'error',
      data: { message: 'Failed to join game' }
    });
  }
}

// Start a game
async function handleStartGame(clientId: string, data: any): Promise<void> {
  try {
    const { gameId } = data;
    
    const success = gameManager.startGame(gameId);
    
    if (success) {
      broadcastToGame(gameId, {
        type: 'gameStarted',
        data: { gameId }
      });
      
      fastify.log.info(`üöÄ Game started: ${gameId}`);
    } else {
      sendToClient(clientId, {
        type: 'error',
        data: { message: 'Failed to start game' }
      });
    }
  } catch (error) {
    fastify.log.error('Error starting game:', error);
    sendToClient(clientId, {
      type: 'error',
      data: { message: 'Failed to start game' }
    });
  }
}

// Handle player movement
async function handlePlayerMove(clientId: string, data: any): Promise<void> {
  try {
    const { gameId, direction } = data;
    
    const game = gameManager.getGame(gameId);
    if (!game) {
      sendToClient(clientId, {
        type: 'error',
        data: { message: 'Game not found' }
      });
      return;
    }
    
    const playerId = clientToPlayer.get(clientId);
    if (!playerId) {
      sendToClient(clientId, {
        type: 'error',
        data: { message: 'Player not found' }
      });
      return;
    }
    
    const input: PlayerInput = {
      type: 'move',
      direction,
      playerId: playerId,
      gameId
    };
    
    game.handlePlayerInput(input);
    
    fastify.log.debug(`üéÆ Player move: ${clientId} -> ${direction}`);
  } catch (error) {
    fastify.log.error('Error handling player move:', error);
  }
}

// Get list of available games
async function handleGetGames(clientId: string): Promise<void> {
  try {
    const games = gameManager.getAllGames().map((game: any) => ({
      id: game.getId(),
      players: game.getPlayers().length,
      status: game.getStatus(),
      maxPlayers: 2
    }));
    
    sendToClient(clientId, {
      type: 'gamesList',
      data: { games }
    });
  } catch (error) {
    fastify.log.error('Error getting games:', error);
    sendToClient(clientId, {
      type: 'error',
      data: { message: 'Failed to get games list' }
    });
  }
}

// Get current game state
async function handleGetGameState(clientId: string, data: any): Promise<void> {
  try {
    const { gameId } = data;
    
    const game = gameManager.getGame(gameId);
    if (!game) {
      sendToClient(clientId, {
        type: 'error',
        data: { message: 'Game not found' }
      });
      return;
    }
    
    sendToClient(clientId, {
      type: 'gameState',
      data: {
        gameId,
        players: game.getPlayers(),
        status: game.getStatus()
      }
    });
  } catch (error) {
    fastify.log.error('Error getting game state:', error);
    sendToClient(clientId, {
      type: 'error',
      data: { message: 'Failed to get game state' }
    });
  }
}

// Leave a game
async function handleLeaveGame(clientId: string, data: any): Promise<void> {
  try {
    const { gameId } = data;
    
    const playerId = clientToPlayer.get(clientId);
    if (!playerId) {
      sendToClient(clientId, {
        type: 'error',
        data: { message: 'Player not found' }
      });
      return;
    }
    
    const game = gameManager.getGame(gameId);
    if (game) {
      game.removePlayer(playerId);
      
      // If no players left, remove the game
      if (game.getPlayers().length === 0) {
        gameManager.removeGame(gameId);
      } else {
        // Notify remaining players
        broadcastToGame(gameId, {
          type: 'playerLeft',
          data: { playerId: playerId }
        });
      }
    }
    
    // Clean up mappings
    playerToClient.delete(playerId);
    clientToPlayer.delete(clientId);
    
    sendToClient(clientId, {
      type: 'gameLeft',
      data: { gameId }
    });
    
    fastify.log.info(`üëã Player left game: ${clientId} from ${gameId}`);
  } catch (error) {
    fastify.log.error('Error leaving game:', error);
  }
}

// Handle client disconnect
function handleClientDisconnect(clientId: string): void {
  const playerId = clientToPlayer.get(clientId);
  
  if (playerId) {
    // Find games where this player is participating
    gameManager.getAllGames().forEach((game: any) => {
      const players = game.getPlayers();
      const playerInGame = players.find((p: any) => p.id === playerId);
      
      if (playerInGame) {
        game.removePlayer(playerId);
        
        // If no players left, remove the game
        if (game.getPlayers().length === 0) {
          gameManager.removeGame(game.getId());
        } else {
          // Notify remaining players
          broadcastToGame(game.getId(), {
            type: 'playerDisconnected',
            data: { playerId: playerId }
          });
        }
      }
    });
    
    // Clean up mappings
    playerToClient.delete(playerId);
    clientToPlayer.delete(clientId);
  }
}

// Health check endpoint
fastify.get('/health', async (request, reply) => {
  return {
    status: 'ok',
    service: 'game-service',
    timestamp: new Date().toISOString(),
    games: {
      total: gameManager.getGameCount(),
      active: gameManager.getActiveGames().length,
      waiting: gameManager.getWaitingGames().length
    }
  };
});

// Game statistics endpoint
fastify.get('/stats', async (request, reply) => {
  return {
    totalGames: gameManager.getGameCount(),
    activeGames: gameManager.getActiveGames().length,
    waitingGames: gameManager.getWaitingGames().length,
    connectedClients: connections.size
  };
});

// Graceful shutdown
process.on('SIGTERM', () => {
  fastify.log.info('üõë Received SIGTERM, shutting down gracefully...');
  gameManager.cleanup();
  fastify.close(() => {
    process.exit(0);
  });
});

process.on('SIGINT', () => {
  fastify.log.info('üõë Received SIGINT, shutting down gracefully...');
  gameManager.cleanup();
  fastify.close(() => {
    process.exit(0);
  });
});

// Start the server
const start = async () => {
  try {
    const port = process.env.PORT || 8000;
    const host = process.env.HOST || '0.0.0.0';
    
    await fastify.listen({ port: Number(port), host });
    fastify.log.info(`üéÆ Game Service running on ${host}:${port}`);
    fastify.log.info(`üîó WebSocket endpoint: ws://${host}:${port}/ws`);
    fastify.log.info(`‚ù§Ô∏è Health check: http://${host}:${port}/health`);
    fastify.log.info(`üìä Stats endpoint: http://${host}:${port}/stats`);
  } catch (err) {
    fastify.log.error('‚ùå Error starting server:', err);
    process.exit(1);
  }
};

start();

// HTTP Routes for game management
// Get all games
fastify.get('/', async (request, reply) => {
  try {
    const allGames = gameManager.getAllGames();
    const formattedGames = allGames.map(game => ({
      id: game.getId(),
      nombre: game.getName(),
      jugadores: game.getPlayers().map(p => ({ nombre: p.name, numero: p.number })),
      jugadoresConectados: game.getPlayers().length,
      capacidadMaxima: 2,
      estado: game.getStatus(),
      tipoJuego: 'pong'
    }));
    
    reply.send({ 
      success: true, 
      games: formattedGames 
    });
  } catch (error) {
    fastify.log.error('Error getting games:', error);
    reply.status(500).send({ 
      success: false, 
      error: 'Failed to get games list' 
    });
  }
});

// Get specific game by ID
fastify.get('/:gameId', async (request: any, reply) => {
  try {
    const { gameId } = request.params;
    const game = gameManager.getGame(gameId);
    
    if (!game) {
      return reply.status(404).send({ 
        success: false, 
        error: 'Game not found' 
      });
    }
    
    const formattedGame = {
      id: game.getId(),
      nombre: game.getName(),
      jugadores: game.getPlayers().map(p => ({ nombre: p.name, numero: p.number })),
      jugadoresConectados: game.getPlayers().length,
      capacidadMaxima: 2,
      estado: game.getStatus(),
      tipoJuego: 'pong'
    };
    
    reply.send({ 
      success: true, 
      game: formattedGame 
    });
  } catch (error) {
    fastify.log.error('Error getting game:', error);
    reply.status(500).send({ 
      success: false, 
      error: 'Failed to get game' 
    });
  }
});

// Create new game
fastify.post('/', async (request: any, reply) => {
  try {
    const { playerName, gameMode = 'pvp', aiDifficulty = 'medium' } = request.body;
    
    if (!playerName) {
      return reply.status(400).send({ 
        success: false, 
        error: 'Player name is required' 
      });
    }
    
    const gameId = gameManager.createGame(playerName, gameMode);
    const game = gameManager.getGame(gameId);
    
    if (game) {
      const formattedGame = {
        id: game.getId(),
        nombre: game.getName(),
        jugadores: game.getPlayers().map(p => ({ nombre: p.name, numero: p.number })),
        jugadoresConectados: game.getPlayers().length,
        capacidadMaxima: 2,
        estado: game.getStatus(),
        tipoJuego: 'pong'
      };
      
      reply.send({ 
        success: true, 
        game: formattedGame 
      });
    } else {
      reply.status(500).send({ 
        success: false, 
        error: 'Failed to create game' 
      });
    }
  } catch (error) {
    fastify.log.error('Error creating game:', error);
    reply.status(500).send({ 
      success: false, 
      error: 'Failed to create game' 
    });
  }
});

// Join game
fastify.post('/:gameId/join', async (request: any, reply) => {
  try {
    const { gameId } = request.params;
    const { playerName } = request.body;
    
    if (!playerName) {
      return reply.status(400).send({ 
        success: false, 
        error: 'Player name is required' 
      });
    }
    
    const success = gameManager.joinGame(gameId, playerName);
    
    if (success) {
      const game = gameManager.getGame(gameId);
      if (game) {
        const formattedGame = {
          id: game.getId(),
          nombre: game.getName(),
          jugadores: game.getPlayers().map(p => ({ nombre: p.name, numero: p.number })),
          jugadoresConectados: game.getPlayers().length,
          capacidadMaxima: 2,
          estado: game.getStatus(),
          tipoJuego: 'pong'
        };
        
        reply.send({ 
          success: true, 
          game: formattedGame 
        });
      } else {
        reply.status(404).send({ 
          success: false, 
          error: 'Game not found' 
        });
      }
    } else {
      reply.status(400).send({ 
        success: false, 
        error: 'Failed to join game' 
      });
    }
  } catch (error) {
    fastify.log.error('Error joining game:', error);
    reply.status(500).send({ 
      success: false, 
      error: 'Failed to join game' 
    });
  }
});

